\chapter{Evaluation of the approaches}
\todo{Lots of stuff to finish}
\section{Library overview}
\begin{table}[ht]
  \begin{tabular}{c|llll}
    Feature (and test)    & LIGD & EMGM & Uniplate & Shapeless \\
                 \hline
    Ad-hoc cases (company) & \checkmark$^{+}$ & $\checkmark$ & \checkmark & \checkmark \\
    Multi-parameter functions (geq) & \checkmark & \checkmark & ($\times$) & \checkmark{} \\
    Extensibility & \checkmark $^{+}$ & $\circ$ & ($\times$) & ($\times$) \\
    First-class generics & \checkmark & $\circ$ & $\circ$ & (\checkmark)
  \end{tabular}


\begin{center}
\textbf{Legend:}\\
\begin{tabular}{llllll}
$\checkmark$ & Well supported & $\circ$ & Supported, but needs effort & $\times$ & Not supported \\
$^{+}$ & Not in Haskell & $()$ & Only tested in Haskell \\
\end{tabular}
\end{center}

  \caption{Feature overview}
\end{table}

The tested libraries support different sets of features. Of the tested libraries,
LIGD and EMGM were the most powerful, and LIGD was the easiest to write for.

\paragraph{Ad-hoc cases}
All tested libraries support ad-hoc cases. In LIGD, only the Scala version
supports ad-hoc cases, due to the availability of sub-typing.

\paragraph{Multi-parameter functions}
Except for uniplate, all libraries support functions with multiple generic
arguments. Uniplate only has limited support for this, not sufficient to
implement generic equality, because it only looks at parts of objects that
have a specific type.

\paragraph{Extensibility}
With the class encoding of functions, LIGD supports
extensibility. EMGM supports extensibility out of the box, but is more verbose
to write than LIGD. \todo{Extensibility in Uniplate/Shapeless}

\paragraph{First class generic functions}
LIGD does not directly first class generic functions, they can be encoded as
objects with an apply method however. This is a limitation of the Scala
language, not a limitation of LIGD itself. See section~\ref{universal-types}
for a discussion on the issue. EMGM supports first class generics to some
extend, but is complicated. Uniplate does not support a really useful form
of first class generics. \todo{First class generic functions in Shapeless}

\section{Performance of the libraries}

To test the performance of the libraries, we ran various tests with them. For
each test, we executed it 600 thousand times, and calculated the average
time of the last 300 thousand executions.

The exact testing framework and all performed tests can be seen in
section~\ref{src:test}.

\begin{table}[ht]
\input{bench}
\caption{Benchmark results}
\label{bench}
\end{table}

As we can see in in table~\ref{bench}, all tested libraries perform roughly
the same time-wise.

\section{Final remarks}
By using Scala language features we solved the issues that made LIGD inferior to
other libraries in Haskell. This, together with the ease of use, makes it one
of the best libraries for generic programming in Scala. Strangely, it also
performs better than EMGM, which has not been the case in Haskell according
to gpbench \cite{DBLP:conf/haskell/RodriguezJJGKO08}. With some work, instances
of \cd{Rep} could probably even be generated automatically using macros. \todo{Explain!}

Shapeless is easiest to use currently, apart from higher-order functions,
mainly because there is no need to write any sort of instances for new types
and because the combinator-based approach leads to short code. It is, however,
difficult to debug code using Shapeless due to the non-straightforward
implementation.

Uniplate only solves a subset of the problems the other libraries solve, but
for those cases, provides a good option. It is, however, not suitable for
generic generic programming.

EMGM provides about the same features as LIGD, but suffers from complexity. It
allows for (forces) functions to be specified on subuniverses only; this can be
seen as an advantage, although it only seems to lead to more boilerplate instances.

In summary, LIGD and Shapeless are probably the best options for generic
programming in Scala right now. With some work, LIGD would probably be even
better.
