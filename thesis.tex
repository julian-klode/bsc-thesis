\documentclass[abstracton,parskip=half]{scrreprt}
\usepackage[english,ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{url}
\usepackage{amssymb}




\lstdefinelanguage{scala}{
  keywords={%
          abstract,case,catch,class,def,do,else,extends,%
          false,final,finally,for,forSome,if,implicit,import,lazy,%
          match,new,null,object,override,package,private,protected,%
          return,sealed,super,this,throw,trait,true,try,type,%
          val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}[keywords,comments,strings]


\lstset{
      basicstyle=\footnotesize,%
      frame=tb,
      basewidth={0.5em,0.45em},
      literate={=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2
               {←}{{$\leftarrow$}}2 {<-}{{$\leftarrow$}}2
               {⇒}{{$\Rightarrow$}}2 {=>}{{$\Rightarrow$}}2
               {<=}{{$\leq$}}2 {|}{{$\mid$}}1
}

\hypersetup{
   hidelinks=true,
   pdfauthor={Julian Andres Klode},
   pdftitle={Bachelor Thesis: Performance and Interfaces of Datatype-Generic Scala Programs},
   pdfsubject={Programming Languages},
}

\author{Julian Andres Klode\\Matriculation number: 2403668\\\\Supervisor: Yufei Cai}
% Let's abuse the subject field for now
\subject{\includegraphics[height=.13\textheight]{graphics/Logo_uni}\\Programming Languages and Software Technology Group\\Prof. Ostermann\\[1.5cm]}
\title{Performance and Interfaces of Datatype-Generic Scala Programs}
\subtitle{Bachelor Thesis}
\newcommand{\cd}{\texttt}
\newcommand{\ex}{\paragraph{Example:}}
\newcommand{\summary}[1]{\textit{\textbf{In short:} #1}}
\date{}


\begin{document}
    \pagenumbering{roman}
    \maketitle{}
    \input{abstract}
    \selectlanguage{english}

    \tableofcontents{}
    \clearpage
    \pagenumbering{arabic}
    \setcounter{page}{1}

    \input{010introduction}


    \chapter{Porting from Haskell to Scala}

    This chapter introduces some basic concepts for translating Haskell code
    to Scala. Most of these concepts were explained by Oliveira and Gibbons~\cite{scalagp}, this
    chapter summarizes them.

    \section{Type classes and Instances}

    Haskell as a concept of type classes and instances, whereas Scala offers
    traits. Traits differ from type classes in that their methods always contain
    an implicit \cd{this} object, that is, they combine data and functions;
    whereas type classes do not reference any data.

    Given a type class like
    \begin{lstlisting}[language=Haskell,gobble=6]
      class MyEq a where
        myEquals :: a -> a -> Boolean
        myEquals a b = False
    \end{lstlisting}
    how do we translate this to Scala? There are two approaches:

    \subsection{Object-oriented translation}
    The object-oriented approach uses traits just like interfaces in
    Java are used. For example, the \cd{MyEq} type class would be translated
    to the following trait:
    \begin{lstlisting}[language=Scala,gobble=6]
      trait MyEq[T] {
        def myEquals(b: T) : Boolean = false
      }
    \end{lstlisting}
    In order to implement this trait for a class the class must extend the
    trait and override the methods of the trait:
    \begin{lstlisting}[language=Scala,gobble=6]
      class MyInt(val i: Int) extends MyEq[MyInt] {
        override def myEquals(b: MyInt) : Boolean = i == b.i
      }
    \end{lstlisting}
    This already shows one deficiency of the traits approach: We cannot
    implement a trait for a type without modifying that type itself.

    Writing a function using this approach is straight forward:
    \begin{lstlisting}[language=Scala,gobble=6]
      def myEquals[T <: MyEq[T]](a: T, b: T) = a.myEquals(b)
    \end{lstlisting}

    This style makes it easy to specify contexts, so for example, if we have
    a class \cd{MyOrd} for ordering that also requires equality, we can write
    \begin{lstlisting}[language=Scala,gobble=6]
      trait MyOrd[T] extends MyEq[T] {
        def myLessOrEqual(b: T) : Boolean
      }
    \end{lstlisting}

    If we want to translate a type class containing a method that does not take a
    parameter of the type A, this style of writing becomes inconsistent.

    \ex Consider the type class
    \begin{lstlisting}[language=Haskell,gobble=6]
      class PerformerFactory a where
        factor :: a
        perform :: a -> Boolean
    \end{lstlisting}
    We can only directly translate the \cd{perform} method to Scala. The \cd{factor}
    method can only be translated by use of a generic function -- this will
    require a stub implementation, that instances can specialize.
    \begin{lstlisting}[language=Scala,gobble=6]
      trait PerformerFactory[A] {
        def factor : A
      }
      def perform[A](a: A) : Boolean = throw new Exception
    \end{lstlisting}
    The end result is inconsistent, because one method is now a method of
    instance objects whereas the other is translated to a global function. It
    also permits instances of the trait that only implement the \cd{factor}
    method.
    \subsection{The functional approach}
    Remember the type class MyEq:
    \begin{lstlisting}[language=Haskell,gobble=6]
      class MyEq a where
        myEquals :: a -> a -> Boolean
        myEquals a b = False
    \end{lstlisting}
    We can ignore the implicit this parameter in traits and translate the type
    class as:
    \begin{lstlisting}[language=Scala,gobble=6]
      trait MyEq[A] {
        def myEquals(a: A, b: A) = false
      }
      def myEquals[T](a: T, b: T)(implicit eq: MyEq[T]) = eq.myEquals(a, b)
    \end{lstlisting}
    We also provided a global \cd{myEquals} function to make our life easier.

    Now in order to implement the trait for a type, we need to define an instance
    of the trait for this type. Instances of those traits correspond to dictionaries
    in Haskell, and can be implemented like this:
    \begin{lstlisting}[language=Scala,gobble=6]
      implicit def MyEqInt = new MyEq[Int] {
        override def myEquals(a: Int, b: Int) = a == b
      }
    \end{lstlisting}
    The \cd{implicit} keyword is a special syntactic sugar provided by Scala
    that makes our work easier. Without it, if we wanted to compare two objects,
    we would need to manually pass the instance of the trait to the function,
    like this:
    \begin{lstlisting}[language=Scala,gobble=6]
      > myEquals(1, 1)(MyEq)
      true
    \end{lstlisting}
    By making \cd{MyEqInt} and the \cd{eq} parameter of \cd{myEquals} implicit,
    the Scala compiler can automatically figure out that \cd{MyEqInt} is the
    correct argument for the \cd{eq} parameter, and we can now run:
    \begin{lstlisting}[language=Scala,gobble=6]
      > myEquals(1, 1)
      true
    \end{lstlisting}


    We can also implement instance that require some sort of context. For
    example, if we want to implement \cd{MyEq} for tuples of objects implementing
    \cd{MyEq} as well, we can write:
    \begin{lstlisting}[language=Scala,gobble=6]
      implicit def myEqTuple[A,B](implicit ea: MyEq[A], eb: MyEq[B]) =
        new MyEq[(A,B)]{
        override def myEquals(a: (A,B), b: (A,B)) = ea.myEquals(a._1, b._1)
                                        && eb.myEquals(a._2, b._2)
      }
    \end{lstlisting}
    Now we can compare tuples: For example, in the following example, Scala will
    automatically infer the correct instance of \cd{MyEq[(Int, Int)]}:
    \begin{lstlisting}[language=Scala,gobble=6]
      > myEquals((1,2), (1,2))
      true
    \end{lstlisting}
    We can still pass  it manually though
    \begin{lstlisting}[language=Scala,gobble=6]
      > myEquals((1,2), (1,2))(myEqTuple(MyEqInt, MyEqInt))
      true
    \end{lstlisting}

    \section{Making the most of type inference}
    \label{type-inference}

    Compared to Haskell, Scala's type inference is weaker. For example, when
    defining a function, the type of parameters need to be defined. An exception
    to this are anonymous functions. If the Scala compiler knows which type the
    function must have, it can automatically infer the type of an anonymous
    function. Thus, in order to avoid repetitious type information in the code,
    we can change our \cd{MyEq} example to:
    \begin{lstlisting}[language=Scala,gobble=6]
      trait MyEq[A] {
        def myEquals : (A => A => Boolean) = a => b => false
      }
      implicit def MyEqInt = new MyEq[Int] {
        override def myEquals = a => b => a == b
      }
    \end{lstlisting}
    Type annotations are not required in method implementations anymore. This
    technique is shown in the port of the EMGM library.

    % Discovered: 2014-08-04
    Another thing that seems to matter a lot is the order of parameters. If
    the less complex types are left of the more complex types, the more
    complex types can be inferred more easily. For example, in Haskell,
    \cd{foldl} has the signature:
    \begin{lstlisting}[language=Haskell,gobble=6]
      foldl :: (a -> b -> a) -> a -> [b] -> a
    \end{lstlisting}
    Scala does not seem to be able to understand this, it will fail to
    infer the type of the first argument. Moving the first argument to
    the end fixes the issue, as Scala can then simply infer from left
    to right. It basically looks like this in Scala (if you ignore that
    the first argument is actually the object which foldLeft is a method
    of):
    \begin{lstlisting}[language=Scala,gobble=6]
      foldLeft[a,b] : [b] => a => (a => b => a) => a
    \end{lstlisting}


    \chapter{Libraries}

    \section{LIGD -- Translation of LIGD}
    \summary{The straight-forward solution to most problems}
    \lstinputlisting[language=scala,firstline=53,lastline=68,float=ht,caption=LIGD Basics,label=ligd-base]{scala/src/ligd.scala}

    LIGD is a simple library that provides a \cd{Rep} trait that describes
    the structure of a type using sums, products, and scalar values.

    Listing~\ref{ligd-base} shows the basic \cd{Rep} trait with instances for
    scalar types, sums (represented using \cd{Either}), and products (represented
    using \cd{Tuple2}). As explained in the previous chapter, we use implicit
    here to allow the compiler to automatically infer the correct \cd{Rep}
    instance for generic function calls.



    \subsection{User-defined types}
    In order to work with user-defined (case) classes, those need to be
    translated to a representation using sums and products. We need an
    isomorphism between the user-defined class and a sum of product type. First
    of all, we can define an isomorphismus as:
    \begin{lstlisting}[language=scala,gobble=6]
      class EP[B, C](val from: B ⇒ C, val to: C ⇒ B)
    \end{lstlisting}
    Now we can define a \cd{Rep} instance, that represents values of a custom
    type \cd{B} and converts it to a sum of product notation of type \cd{C},
    something like this:
    \begin{lstlisting}[language=scala,gobble=6]
      case class RType[C, B](val c: Rep[C], val ep: EP[B, C]) extends Rep[B]
    \end{lstlisting}
    There is one problem though: The representation of \cd{C} may be recursive,
    for example a list type is a sum of nothing, and a product of an element and
    the list type. Thus, the parameter \cd{c} must be lazy. Scala does not allow
    lazy \cd{val}s on case classes, though, so this needs to be worked around.

    There are two approaches: One is encoding the thunk manually, like:
    \begin{lstlisting}[language=scala,gobble=6]
      case class RType[C, B](val c: () => Rep[C], val ep: EP[B, C]) extends Rep[B]
    \end{lstlisting}
    This is very easy, but looks inconsistent in usage. Another approach is to
    not use a case class and provide a companion object with custom \cd{apply}
    and \cd{unapply} methods. Listing~\ref{ligd-rtype} shows how this is
    implemented.
    \lstinputlisting[language=scala,firstline=76,lastline=95,float=ht,caption=Implementation of RType,label=ligd-rtype]{scala/src/ligd.scala}

    \textbf{Example (Lists):} In order to represent a list, we encode the
    list as a sum of products, or to be precise, we want to encode a \cd{List[A]}
    as: \cd{Either[Unit, (A, List[A])]}. In order to do this, we need functions
    that convert from \cd{List[A]} to \cd{Either[Unit, (A, List[A])]} and
    vice versa. An implementation of those functions is given in figure~\ref{ligd-rlist}.
    %-- We can then define an RType instance as:
    %\lstinputlisting[language=scala,firstline=109,lastline=113]{scala/src/ligd.scala}

    \lstinputlisting[language=scala,firstline=101,lastline=122,float=ht,caption=Implementation of rList,label=ligd-rlist]{scala/src/ligd.scala}

    Note how the first parameter of \cd{RType} is recursive.

    \subsection{Writing generic functions}
    Writing generic functions using LIGD is simple. We just pass the object(s)
    we are interested in to the function, along with their type representations,
    and then pattern match on the type representations.

      \lstinputlisting[language=scala,firstline=35,lastline=50,float=ht,caption=Generic Equality in LIGD,label=ligd-geq]{scala/src/ligd.scala}

    This function is pretty much self-explaining.

    \subsection{Differences to the Haskell implementation}
    One minor difference is that we implemented \cd{Rep} like we would implement
    a type class in Haskell. The original paper manually passed around \cd{Rep}
    instances for generic functions, we make use of Scala's implicit values.


    \subsubsection{Ad-hoc cases using subtyping}
    A key difference that extends the functionality of LIGD in Scala is that
    Scala permits sub-typing. If we look at our definition of RType, we see
    that it is not \cd{sealed}, allowing it to be extended by subclasses.

    We can use this to create custom sub classes for types we are interested
    in, and pattern match on them. Because those are sub classes of \cd{RType},
    existing code will be unaffected by new types.

    An example for this is the list type. Because we extended \cd{RType} as
    \cd{RList} we can now write a generic function that finds all lists of a
    specific element type in a data structure.

    \subsubsection{Equality comparisons of type representations}
    The Haskell version of LIGD does not support comparing Rep instances
    against each other. This is quite useful, though, as it allows to
    implement simple variants of generic operations that look for objects
    of a specific type in another object.


    When representing generic types such as Lists, we can create a subclass
    of RType with parameters representing the generic arguments. We can then
    define a custom \cd{equals()} method, as seen in listing~\ref{rmycustomtype}.

    \begin{lstlisting}[language=Scala,gobble=8,float,caption=Representing custom generic types,label=rmycustomtype]
        class RMyCustomType[T1, ...](r1: Rep[T1], ...) {
            override def equals(b: Any) : Boolean = b match {
                case RMyCustomType(r1, ...) => r1 == this.r1 &&
                                               r2 == this.r2 && ...
                case _ => false
            }
        }
    \end{lstlisting}



    \section{EMGM -- Translation of Extensible and Modular Generics for the Masses}
    \summary{More verbose (especially for ad-hoc cases) than LIGD}


    In Generics for the Masses \cite{GM}, Ralf Hinze introduces an alternative
    encoding of generic functions. While objects are still viewed as sums and
    products of scalar values, generic functions are now defined as instances
    of a \cd{Generic} type class, with one method for each type of object
    supported, our slightly extended version can be seen in Figure~\ref{src:emgm:Generic}
    \lstinputlisting[language=scala,firstline=40,lastline=50,label=src:emgm:Generic,caption=The \cd{Generic} trait in GM,showstringspaces=false]{scala/src/emgm.scala}
    The parameter \cd{G} refers to a type constructor for a type that stores
    a function of a specific type -- For example, imagine we want to check
    arbitrary objects of the same type for equality. Our type \cd{G[\_]} must have a function that accepts two
    value of the type given by the first parameter, and returns a boolean
    -- see Listing~\ref{src:emgm:GEq}.
    \lstinputlisting[language=scala,firstline=179,lastline=196,float=ht,label=src:emgm:GEq,caption=A generic equality function in GM,showstringspaces=false]{scala/src/emgm.scala}

    We use closures here instead of normal methods in order to have the
    compiler infer the types automatically, as explained in Section~\ref{type-inference}.

    Being able to represent generic functions is only half of the work, though
    -- we still need a way to represent objects. Instead of converting objects
    to a representation of sums and products, we simply call the members of
    the \cd{Generic} instance we need.

    \lstinputlisting[language=scala,firstline=58,lastline=82,float=ht,label=src:emgm:Rep,caption=The \cd{Rep} trait in GM,showstringspaces=false]{scala/src/emgm.scala}

    We can now, similar to  LIGD, represent arbitrary types as sums of products.
    Recall the list example from LIGD.
    As we can see in Figure~\ref{src:emgm:rList}, the definition is similar to
    the one in LIGD
    -- the isomorphism is basically the same, the only difference is the slightly
    more verbose definition of \cd{RList}, because we need to split the generic
    function `creation' (the description of the type) out in \cd{rList}.

    We will see that this only gets worse once we introduce ad-hoc cases.
    \lstinputlisting[language=scala,firstline=119,lastline=138,float=ht,label=src:emgm:rList,caption=Representing lists in GM,showstringspaces=false]{scala/src/emgm.scala}

    \subsection{Extensibility and Modularity}
    Now consider that we want to treat lists specially, that is, create an
    ad-hoc case of \cd{geq} that handles lists directly, instead of as a
    sum of products representations. That is, we need a subclass of Generic
    that can work on lists, something like:
    \lstinputlisting[language=scala,firstline=240,lastline=242,label=src:emgm:GenericList,caption=,showstringspaces=false]{scala/src/emgm.scala}
    Note that the special case for lists defers to the sum of product variant
    if it is not handled by the generic function. We can thus use that extra
    method (override it) or ignore it (and treat it using sums and products).
    \lstinputlisting[language=scala,firstline=253,lastline=270,float=ht,label=src:emgm:GEqList,caption=Generic equality specialised to lists,showstringspaces=false]{scala/src/emgm.scala}

    What we are still missing is a sort of dispatcher, like \cd{Rep} in Generics
    for the masses. Without such a dispatcher, using generic functions like
    \cd{GEqList} would not be easy.

    \subsection{Comparison to LIGD}

    %EMGM \cite{emgm} improves on a framework for generic programming first introduced

    \clearpage
    \section{Uniplate}
    \summary{Not feasible without macros or code generators and fails generic equality test}

    Uniplate is a library that differentiates between two basic type of
    objects: Uniplates and Biplates. Uniplates are simple recursive types
    like terms or expressions, which form a graph where all inner nodes have
    the same common supertype. Biplates are types that contain other Uniplates,
    for example, a \cd{List a} has a \cd{Biplate List a}.


    Uniplate can theoretically be ported from Haskell to Scala, but it is not
    feasible to do without a way to automatically generate instances of the
    \cd{Biplate} type class, because the amount of biplates needed is quadratic
    to the number of types.

    Due to the way uniplate works, it is not possible to implement a generic
    equality function for two biplate objects. Because biplates work by only
    looking at a subset of the types elements (for example, a \cd{Biplate[Company,Salary]}
    only cares about Salaries in a company -- not enough to compare two companies). Even
    for Uniplates, defining a generic equality function won't work because we
    only have access to the objects themselves and not to members of a different
    type.

    A basic implementation of uniplate can be found in the \cd{uniplate.scala}
    source file in section~\ref{src:uniplate}.


    \section{Shapeless -- Scala Implementation of Scrap your Boilerplate}

    Shapeless is an adaption of Scrap your Boilerplate\cite{DBLP:conf/tldi/LammelJ03}
    from Haskell to Scala. Compared to the Haskell implementation, the Scala
    implementation simplifies some things a bit.

    Comparing our ports of other libraries against shapeless helps us determine
    whether the solutions are efficient.

    I found Shapeless to be buggy. Defining a generic function and calling
    it twice in the interpreter resulted in errors:
    \begin{lstlisting}[language=Scala,gobble=6]
      scala> def inc(i: Int) = i + 1
      inc: (i: Int)Int

      scala> everywhere(inc _)(List(1,2,3))
      res7: List[Int] = List(2, 3, 4)

      scala> everywhere(inc _)(List(1,2,3))
      java.lang.AbstractMethodError: fresh$macro$6$2$.caseUniv()Lshapeless/PolyDefns$Case;
        ... 43 elided
    \end{lstlisting}

    Furthermore, testing it with a standard paradise benchmark, increasing all
    salaries by 10\% failed as well sometimes, with shapeless only increasing
    some of the values when run under scalatest.

    \chapter{Implementing Datatype-Generic Programming in Scala}
    \section{Name-binding Operations}
    \section{Derived Data Types}
    \section{GPBench}
    GPBench is a suite of benchmarks for comparing generic programming
    libraries in Haskell \cite{DBLP:conf/haskell/RodriguezJJGKO08}.

    \section{Benchmarks}

    To test the performance of the libraries, we ran various tests with them. For
    each test, we executed it 600 thousand times, and calculated the average
    time of the last 300 thousand executions.

    \begin{table}[ht]
    \input{bench}
    \caption{Benchmark results}
    \label{bench}
    \end{table}

    As we can see in in table~\ref{bench}, all tested libraries perform roughly
    the same time-wise.


    \chapter{Conclusion}

    \begin{table}[t!]
      \begin{tabular}{c|cccc}
        Feature (and test)    & LIGD & EMGM & Uniplate & Shapeless \\
                     \hline
        Ad-hoc cases (company) & \checkmark & \checkmark & \checkmark & \checkmark \\
        Multi-parameter functions (geq) & \checkmark & \checkmark & ($\times$) & \checkmark
      \end{tabular}

      \caption{Feature overview}
    \end{table}

    \bibliographystyle{alpha}
    \bibliography{thesis}

    \appendix{}
    \chapter{Source Code}

    \lstset{frame=none}
    \section{LIGD}
    \lstinputlisting[language=scala,firstline=19,label=src:ligd,showstringspaces=false]{scala/src/ligd.scala}
    \subsection{Company data}
    \lstinputlisting[language=scala,firstline=19,label=src:ligd-company,showstringspaces=false]{scala/src/ligd-company.scala}
    \section{EMGM}
    \lstinputlisting[language=scala,firstline=19,label=src:emgm,showstringspaces=false]{scala/src/emgm.scala}
    \subsection{Company data}
    \lstinputlisting[language=scala,firstline=19,label=src:emgm-company,showstringspaces=false]{scala/src/emgm-company.scala}
    \section{Uniplate}
    \lstinputlisting[language=scala,firstline=19,label=src:uniplate,showstringspaces=false]{scala/src/uniplate.scala}
    \section{Test Data}
    \lstinputlisting[language=scala,firstline=19,label=src:data,showstringspaces=false]{scala/src/data.scala}
    \section{Unit tests}
    \subsection{Paradise benchmark (TODO)}
    \lstinputlisting[language=scala,firstline=19,label=tests:companytest,showstringspaces=false]{scala/tests/CompanyTest.scala}
    \subsection{EMGM}
    \lstinputlisting[language=scala,firstline=19,label=tests:emgm,showstringspaces=false]{scala/tests/emgm.scala}
    \subsection{LIGD}
    \lstinputlisting[language=scala,firstline=19,label=tests:ligd,showstringspaces=false]{scala/tests/ligd.scala}
    \subsection{Uniplate}
    \lstinputlisting[language=scala,firstline=1,label=tests:uniplate,showstringspaces=false]{scala/tests/uniplate.scala}

    \section{Benchmark}
    \lstinputlisting[language=scala,firstline=19,label=src:test-,showstringspaces=false]{scala/src/test.scala}
\end{document}
