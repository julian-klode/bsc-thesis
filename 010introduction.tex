\chapter{Introduction}
any programming languages -- for example; Haskell, Java, Scala, C++ --
these days support a form of parametric polymorphism.
Parametric Polymorphism allows the definition of data types that abstract over
the type of some element they store, such as lists that can store elements of
some unspecified type \lstinline{a}:
\begin{lstlisting}
sealed abstract class List[a]
case class Nil[a]() extends List[a]
case class Cons[a](car: a, cdr: List[a]) extends List[a]
\end{lstlisting}
In Scala and other object-oriented (or influenced) languages this concept is
called generics.
Datatype-generic programming is a different concept. Instead of abstracting
over the type of the elements, it abstracts over the containing type.

For example, increasing all integers in a data structure is an example for a
datatype-generic operation. We basically want to write something like:
\begin{lstlisting}
def incInt[C](c: C) = everywhere((i: Int) => i + 1)(c)
\end{lstlisting}
or (if we want to restrict it to types storing integers)
\begin{lstlisting}
def incInt[C[_]](c: C[Int]) = everywhere((i: Int) => i + 1)(c)
\end{lstlisting}
And as we will see in later chapters, we can indeed write something very similar,
albeit with some additional (implicit) parameters.

Scala is an interesting language to look at because it offers some features Haskell
does not have in the type system, like sub typing (unsealed classes). It is also
eager and not lazy, further complicating some operations, as we will see.
