\chapter{Introduction}
Datatype-generic operations are operations that are defined over the shapes
of objects rather than any specific types of objects. This is different from
the concept of parametric polymorphism, also called generic programming in
languages like Scala:

Where parametric polymorphism abstracts away the elements of a container,
datatype-generic programming essentially abstracts away the container.

In the rest of this thesis, `generic programming' means `datatype-generic
programming'.


\begin{example}[Parametric polymorphism]
The type constructor \cd{List} is an example for parametric polymorphism. For
example, you can generate the length of a list:

\begin{lstlisting}
    def length[T](list: List[T]) = ...
\end{lstlisting}
\end{example}

\begin{example}[Datatype-generic operation]
A datatype-generic operation is an operation that abstracts the outer type, and
works with specific inner types. For example, a sum that can work on containers
of integers; that is, something like:
\begin{lstlisting}
    def sum[C[_]](list: C[Int]) = ...
\end{lstlisting}
\end{example}

There are two basic ways of how datatype-generic programming libraries expose
their interfaces:

\begin{enumerate}
    \item By representing objects as sums and products
    \item By providing combinators for performing operations
\end{enumerate}

In the first style, a generic operation will traverse the data structure and
perform its operation. In the second style, the generic library takes care of
the traversal and offers some combinators to allow working with the elements.
As a comparison: The first style is similar to traversing a list manually whereas
the second style resembles a fold.
